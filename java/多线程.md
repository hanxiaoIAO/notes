[toc]

## 参考文章

[1]:https://blog.csdn.net/qq_41212104/article/details/81773717 "史上最全 Java 多线程面试题及答案"
[2]: https://blog.csdn.net/ThinkWon/article/details/102021274 "进程和线程的区别(超详细)"

## 多线程优势

1. 发挥多核CPU的优势

2. 防止阻塞

   单线程的情况下，如果某个任务耗时较长，会导致整个进程的阻塞。

3. 便于建模

   可以将任务分解，不同的线程执行不同的任务。

## 单核多线程和多核多线程

## 进程与线程

进程是一个正在运行的程序的实例(an instance of a computer program that is being excuted)。

线程是程序执行过程中的最小单元。



## 线程状态

线程状态：新建、就绪、运行、阻塞、死亡。

## 线程的优先级

每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。

Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。

默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。

具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。

## 创建一个线程

Java 提供了三种创建线程的方法：

- 通过实现 Runnable 接口；

```java
public class MyRun implements Runnable{
	public void run(){
		while(true){
			System.out.println("MyThread类的run()方法在运行");
		}
	}
}

public class MyMain {
    public static void main(String[] args)  {
    	MyRun run = new MyRun();
        Thread thread = new Thread(run);
        thread.start();
        
        System.out.println("done");
    }
}
```



- 通过继承 Thread 类本身；

```java
public class MyThread extends Thread{
    private static int num = 0;
     
    public MyThread(){
        num++;
    }
     
    @Override
    public void run() {
    	while(true)
        System.out.println("主动创建的第"+num+"个线程");
    }
}

public class MyMain {
    public static void main(String[] args)  {
    	MyThread thread = new MyThread();
        thread.start();
        
        System.out.println("done");
    }
}
```



- 通过 Callable 和 Future 创建线程。

```java
public class MyCallable implements Callable<Integer> {
	@Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i <= 100000; i++) {
            sum = i;
        }
        return sum;
    }
}

public class MyMain {
	public static void main(String[] args) throws Throwable {
		//方式1 利用线程池
		ExecutorService executor = Executors.newCachedThreadPool();
		MyCallable callabe = new MyCallable();
		Future<Integer> future = executor.submit(callabe);
		System.out.println(future.get());
		executor.shutdown();
		//方式2 利用线程池
		ExecutorService executor1 = Executors.newCachedThreadPool();
		MyCallable callabe1 = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<Integer>(callabe1);
       	Future<?> future1 =  executor1.submit(futureTask);
        System.out.println(futureTask.get());
        System.out.println(future1.get());
        executor1.shutdown();
        //方式3
        MyCallable callabe2 = new MyCallable();
        FutureTask<Integer> futureTask2 = new FutureTask<Integer>(callabe2);
        Thread thread = new Thread(futureTask1);
        thread.start();
        System.out.println(futureTask2.get());
	}
}

```



- 通过线程池创建线程

### Callable和Runable的差别

1. Callable规定的方法是call()，而Runnable规定的方法是run()。

2. Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。  

3. call()方法可抛出异常，而run()方法是不能抛出异常的。 

4. Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。 

   

1.   运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。 
2.   它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。 
3.   通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。 

## 线程等待

主线程等待子线程完成后继续

### join()

```java
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class ThreadDemo {
	 
    public static void main(String[] args) throws InterruptedException {
        List<Thread> list = new CopyOnWriteArrayList<>();
        //启用5个线程
        for(int i=1;i<=10;i++){
            Thread childrenThread=new Thread(new Runnable(){
                 public void run(){
                     try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                     System.out.println(this.toString()+"子线程执行！");
                     
                 }
            });
            list.add(childrenThread);
            childrenThread.start();
        }
        //主线程
        for(Thread thread : list){
            thread.join(); //使用join来保证childrenThread的5个线程都执行完后，才执行主线程
        }
        System.out.println("主线程执行！");
    }
}
```

## 其他并发工具类 CountDownLatch 和 CyclicBarrier

```java
import java.util.concurrent.CountDownLatch;

public class ThreadDemo {
	 
	  public static void main(String[] args) throws InterruptedException {
	        CountDownLatch latch= new CountDownLatch(10);//使用java并发库concurrent
	        //启用5个线程
	        for(int i=1;i<=10;i++){
	            new Thread(new Runnable(){
	                 public void run(){
	                     try {
	                        Thread.sleep(1000);
	                    } catch (Exception e) {
	                        e.printStackTrace();
	                    }
	                     System.out.println("子线程执行！");
	                     latch.countDown();//让latch中的数值减一
	                     
	                 }
	            }).start();
	            
	        }
	        //主线程
	        latch.await();//阻塞当前线程直到latch中数值为零才执行
	        System.out.println("主线程执行！");
	    }
}
```

```java
import java.util.concurrent.CyclicBarrier;

public class ThreadDemo {
	 
	 public static void main(String[] args) throws Exception {
	        CyclicBarrier barrier=new CyclicBarrier(5);
	        //启用5个线程
	        for(int i=1;i<=5;i++){
	            new Thread(new Runnable(){
	                 public void run(){
	                     try {
	                        Thread.sleep(1000);
	                    } catch (Exception e) {
	                        e.printStackTrace();
	                    }
	                     System.out.println("子线程执行！");
	                     try {
	                        barrier.await();//到达屏障
	                    } catch (Exception e) {
	                        e.printStackTrace();
	                    }
	                     
	                 }
	            }).start();
	            
	        }
	        //主线程
	        barrier.await();//阻塞当前线程直到latch中数值为零才执行
	        System.out.println("主线程执行！");
	    }
}
```

### CountDownLatch和CyclicBarrier的比较

1. CountDownLatch是线程组之间的等待，即一个(或多个)线程等待N个线程完成某件事情之后再执行；而CyclicBarrier则是线程组内的等待，即每个线程相互等待，即N个线程都被拦截之后，然后依次执行。
2. CountDownLatch是减计数方式，而CyclicBarrier是加计数方式。
3. CountDownLatch计数为0无法重置，而CyclicBarrier计数达到初始值，则可以重置。
4. CountDownLatch不可以复用，而CyclicBarrier可以复用。

